// EVMS (c) Shane D. Shook, PhD, 2025 All Rights Reserved
// Vulnerability scanning agent

const logger = require('../../../utils/logger');
const { spawn } = require('child_process');
const fs = require('fs').promises;
const { v4: uuidv4 } = require('uuid');

class VulnerabilityScanner {
  constructor(natsClient, graphDB) {
    this.natsClient = natsClient;
    this.graphDB = graphDB;
    this.initialized = false;
    this.running = false;
    this.activeTasks = new Map();
    this.scanners = {
      nmap: '/usr/bin/nmap',
      nikto: '/usr/bin/nikto',
      nuclei: '/usr/bin/nuclei'
    };
    this.cveDatabase = new Map();
  }

  async initialize() {
    try {
      logger.info('Initializing Vulnerability Scanner');
      
      // Check available scanners
      await this.checkScannerAvailability();
      
      // Load vulnerability databases
      await this.loadVulnerabilityDatabases();
      
      this.initialized = true;
      logger.info('Vulnerability Scanner initialized successfully');
    } catch (error) {
      logger.error('Failed to initialize Vulnerability Scanner', { error: error.message });
      throw error;
    }
  }

  async start() {
    try {
      if (!this.initialized) {
        throw new Error('Vulnerability Scanner not initialized');
      }

      this.running = true;
      logger.info('Vulnerability Scanner started successfully');
    } catch (error) {
      logger.error('Failed to start Vulnerability Scanner', { error: error.message });
      throw error;
    }
  }

  async stop() {
    try {
      this.running = false;
      
      // Cancel all active tasks
      for (const [taskId, task] of this.activeTasks) {
        await this.cancelTask(taskId);
      }
      
      this.activeTasks.clear();
      logger.info('Vulnerability Scanner stopped successfully');
    } catch (error) {
      logger.error('Failed to stop Vulnerability Scanner', { error: error.message });
      throw error;
    }
  }

  async checkScannerAvailability() {
    const availableScanners = {};
    
    for (const [name, path] of Object.entries(this.scanners)) {
      try {
        await fs.access(path);
        availableScanners[name] = true;
        logger.info(`Scanner available: ${name}`);
      } catch (error) {
        availableScanners[name] = false;
        logger.warn(`Scanner not available: ${name}, using built-in alternatives`);
      }
    }
    
    this.availableScanners = availableScanners;
    
    // Always have built-in scanner available
    this.availableScanners.builtin = true;
  }

  async loadVulnerabilityDatabases() {
    try {
      // Load sample CVE database
      const sampleCVEs = [
        {
          id: 'CVE-2021-44228',
          description: 'Apache Log4j2 JNDI features do not protect against attacker controlled LDAP',
          severity: 'critical',
          cvssScore: 10.0,
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-44228']
        },
        {
          id: 'CVE-2021-45046',
          description: 'Apache Log4j2 Thread Context Lookup Pattern vulnerable to DoS',
          severity: 'high',
          cvssScore: 9.0,
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-45046']
        },
        {
          id: 'CVE-2020-15778',
          description: 'OpenSSH allows privilege escalation via certain configurations',
          severity: 'high',
          cvssScore: 7.8,
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-15778']
        }
      ];
      
      for (const cve of sampleCVEs) {
        this.cveDatabase.set(cve.id, cve);
      }
      
      logger.info(`Loaded ${this.cveDatabase.size} CVE entries`);
    } catch (error) {
      logger.error('Failed to load vulnerability databases', { error: error.message });
      throw error;
    }
  }

  async executeTask(task) {
    try {
      const { taskId, type, targets, parameters } = task;
      
      logger.info('Executing vulnerability scan task', { taskId, targets });
      
      this.activeTasks.set(taskId, { ...task, status: 'running', startTime: new Date() });
      
      const results = await this.performVulnerabilityScan(targets, parameters);
      
      this.activeTasks.delete(taskId);
      
      logger.info('Vulnerability scan completed', { 
        taskId, 
        vulnerabilityCount: results.vulnerabilities.length 
      });
      
      return results;
    } catch (error) {
      this.activeTasks.delete(task.taskId);
      logger.error('Vulnerability scan failed', { taskId: task.taskId, error: error.message });
      throw error;
    }
  }

  async performVulnerabilityScan(targets, parameters = {}) {
    const results = {
      vulnerabilities: [],
      scanMetadata: {
        startTime: new Date().toISOString(),
        targets,
        scanType: 'vulnerability_scan',
        parameters
      }
    };
    
    for (const target of targets) {
      try {
        logger.info('Scanning target for vulnerabilities', { target });
        
        // Perform different types of scans based on target type
        if (this.isIPAddress(target) || this.isHostname(target)) {
          const networkVulns = await this.scanNetworkVulnerabilities(target, parameters);
          results.vulnerabilities.push(...networkVulns);
          
          const webVulns = await this.scanWebVulnerabilities(target, parameters);
          results.vulnerabilities.push(...webVulns);
        } else if (this.isURL(target)) {
          const webVulns = await this.scanWebVulnerabilities(target, parameters);
          results.vulnerabilities.push(...webVulns);
        }
        
      } catch (error) {
        logger.error('Failed to scan target', { target, error: error.message });
        
        // Add scan error as a finding
        results.vulnerabilities.push({
          id: uuidv4(),
          target,
          title: 'Scan Error',
          description: `Failed to scan target: ${error.message}`,
          severity: 'info',
          cvssScore: 0,
          type: 'scan_error',
          discoveredAt: new Date().toISOString()
        });
      }
    }
    
    results.scanMetadata.endTime = new Date().toISOString();
    results.scanMetadata.duration = new Date() - new Date(results.scanMetadata.startTime);
    
    return results;
  }

  async scanNetworkVulnerabilities(target, parameters) {
    const vulnerabilities = [];
    
    try {
      // Port scan to identify open services
      const openPorts = await this.performPortScan(target, parameters);
      
      for (const port of openPorts) {
        // Check for known vulnerable services
        const serviceVulns = await this.checkServiceVulnerabilities(target, port);
        vulnerabilities.push(...serviceVulns);
      }
      
    } catch (error) {
      logger.error('Network vulnerability scan failed', { target, error: error.message });
    }
    
    return vulnerabilities;
  }

  async performPortScan(target, parameters) {
    // Simplified port scan for demo purposes
    const commonPorts = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306];
    const openPorts = [];
    
    // Simulate port scanning with realistic results
    const portProbabilities = {
      22: 0.8,   // SSH commonly open
      80: 0.7,   // HTTP commonly open
      443: 0.6,  // HTTPS commonly open
      25: 0.3,   // SMTP sometimes open
      3306: 0.2, // MySQL sometimes open
      5432: 0.2, // PostgreSQL sometimes open
      21: 0.1,   // FTP rarely open
      23: 0.05,  // Telnet rarely open
      3389: 0.1  // RDP sometimes open
    };
    
    for (const port of commonPorts) {
      const probability = portProbabilities[port] || 0.1;
      if (Math.random() < probability) {
        openPorts.push({
          port,
          protocol: 'tcp',
          service: this.getServiceForPort(port),
          state: 'open'
        });
      }
    }
    
    return openPorts;
  }

  getServiceForPort(port) {
    const serviceMap = {
      21: 'ftp',
      22: 'ssh',
      23: 'telnet',
      25: 'smtp',
      53: 'dns',
      80: 'http',
      110: 'pop3',
      143: 'imap',
      443: 'https',
      993: 'imaps',
      995: 'pop3s',
      3389: 'rdp',
      5432: 'postgresql',
      3306: 'mysql'
    };
    
    return serviceMap[port] || 'unknown';
  }

  async checkServiceVulnerabilities(target, portInfo) {
    const vulnerabilities = [];
    const { port, service } = portInfo;
    
    // Check for known vulnerable services
    const knownVulns = this.getKnownServiceVulnerabilities(service, port);
    
    for (const vuln of knownVulns) {
      vulnerabilities.push({
        id: uuidv4(),
        target,
        port,
        service,
        cveId: vuln.cveId,
        title: vuln.title,
        description: vuln.description,
        severity: vuln.severity,
        cvssScore: vuln.cvssScore,
        type: 'service_vulnerability',
        discoveredAt: new Date().toISOString(),
        references: vuln.references || []
      });
    }
    
    return vulnerabilities;
  }

  getKnownServiceVulnerabilities(service, port) {
    const vulnerabilities = [];
    
    // Simulate vulnerability detection based on service
    switch (service) {
      case 'ssh':
        if (Math.random() > 0.7) {
          vulnerabilities.push({
            cveId: 'CVE-2020-15778',
            title: 'OpenSSH Privilege Escalation',
            description: 'OpenSSH allows privilege escalation via certain configurations',
            severity: 'high',
            cvssScore: 7.8
          });
        }
        break;
        
      case 'http':
      case 'https':
        if (Math.random() > 0.6) {
          vulnerabilities.push({
            cveId: 'CVE-2021-44228',
            title: 'Log4j Remote Code Execution',
            description: 'Apache Log4j2 JNDI features vulnerable to RCE',
            severity: 'critical',
            cvssScore: 10.0
          });
        }
        break;
        
      case 'ftp':
        if (Math.random() > 0.8) {
          vulnerabilities.push({
            cveId: 'CVE-2019-12815',
            title: 'ProFTPD File Copy Vulnerability',
            description: 'ProFTPD allows arbitrary file copy via mod_copy',
            severity: 'medium',
            cvssScore: 6.5
          });
        }
        break;
        
      case 'mysql':
        if (Math.random() > 0.7) {
          vulnerabilities.push({
            cveId: 'CVE-2021-2194',
            title: 'MySQL Server Vulnerability',
            description: 'MySQL Server allows unauthorized access to data',
            severity: 'medium',
            cvssScore: 6.8
          });
        }
        break;
    }
    
    return vulnerabilities;
  }

  async scanWebVulnerabilities(target, parameters) {
    const vulnerabilities = [];
    
    try {
      // Perform basic web vulnerability checks
      const basicWebVulns = await this.performBasicWebScan(target, parameters);
      vulnerabilities.push(...basicWebVulns);
      
    } catch (error) {
      logger.error('Web vulnerability scan failed', { target, error: error.message });
    }
    
    return vulnerabilities;
  }

  async performBasicWebScan(target, parameters) {
    const vulnerabilities = [];
    
    // Simulate common web vulnerabilities
    const commonWebVulns = [
      {
        title: 'Missing Security Headers',
        description: 'Server is missing important security headers (X-Frame-Options, CSP, etc.)',
        severity: 'medium',
        cvssScore: 5.3,
        type: 'configuration'
      },
      {
        title: 'Outdated Software Version',
        description: 'Web server is running an outdated version with known vulnerabilities',
        severity: 'high',
        cvssScore: 7.5,
        type: 'version'
      },
      {
        title: 'Directory Listing Enabled',
        description: 'Directory listing is enabled, potentially exposing sensitive files',
        severity: 'low',
        cvssScore: 3.1,
        type: 'information_disclosure'
      },
      {
        title: 'Weak SSL/TLS Configuration',
        description: 'SSL/TLS configuration uses weak ciphers or protocols',
        severity: 'medium',
        cvssScore: 5.9,
        type: 'ssl_tls'
      },
      {
        title: 'Cross-Site Scripting (XSS)',
        description: 'Potential XSS vulnerability detected in web application',
        severity: 'high',
        cvssScore: 8.2,
        type: 'xss'
      },
      {
        title: 'SQL Injection',
        description: 'Potential SQL injection vulnerability detected',
        severity: 'critical',
        cvssScore: 9.8,
        type: 'sql_injection'
      }
    ];
    
    // Randomly add some vulnerabilities for demo
    for (const vuln of commonWebVulns) {
      if (Math.random() > 0.6) {
        vulnerabilities.push({
          id: uuidv4(),
          target,
          cveId: null,
          title: vuln.title,
          description: vuln.description,
          severity: vuln.severity,
          cvssScore: vuln.cvssScore,
          type: vuln.type,
          discoveredAt: new Date().toISOString()
        });
      }
    }
    
    return vulnerabilities;
  }

  async cancelTask(taskId) {
    const task = this.activeTasks.get(taskId);
    if (task) {
      task.status = 'cancelled';
      this.activeTasks.delete(taskId);
      logger.info('Vulnerability scan task cancelled', { taskId });
    }
  }

  // Utility methods
  isIPAddress(target) {
    const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
    return ipRegex.test(target);
  }

  isHostname(target) {
    const hostnameRegex = /^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$/;
    return hostnameRegex.test(target) && !this.isIPAddress(target);
  }

  isURL(target) {
    try {
      new URL(target);
      return true;
    } catch {
      return false;
    }
  }

  getMetrics() {
    return {
      activeTasks: this.activeTasks.size,
      availableScanners: this.availableScanners,
      cveDatabase: this.cveDatabase?.size || 0,
      totalScansCompleted: this.totalScansCompleted || 0
    };
  }

  async healthCheck() {
    try {
      return {
        healthy: this.running && this.initialized,
        availableScanners: this.availableScanners,
        activeTasks: this.activeTasks.size
      };
    } catch (error) {
      return { healthy: false, error: error.message };
    }
  }
}

module.exports = VulnerabilityScanner;
